<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SyncLiked - Spotify Playlist Manager</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéµ</text></svg>">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        spotify: '#1db954',
                        'spotify-hover': '#1ed760'
                    }
                }
            }
        }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Simple UI Components
        const Button = ({ children, onClick, disabled, className, type = "button", variant = "default" }) => {
            const baseClasses = "px-4 py-2 rounded-lg font-medium transition-all duration-200 min-h-[44px] flex items-center justify-center gap-2";
            const variants = {
                default: "bg-[#1db954] hover:bg-[#1ed760] text-white hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100",
                outline: "border border-gray-600 text-white hover:bg-gray-800 hover:border-gray-500 bg-transparent",
                ghost: "text-[#1db954] hover:text-[#1ed760] hover:bg-[#1db954]/10 bg-transparent border-none"
            };
            
            return (
                <button 
                    type={type}
                    onClick={onClick} 
                    disabled={disabled}
                    className={`${baseClasses} ${variants[variant]} ${className || ''}`}
                >
                    {children}
                </button>
            );
        };

        const Card = ({ children, className }) => (
            <div className={`bg-[#1e1e1e] border border-gray-800 rounded-lg ${className || ''}`}>
                {children}
            </div>
        );

        const Input = ({ value, onChange, placeholder, type = "text", required, className, id }) => (
            <input
                id={id}
                type={type}
                value={value}
                onChange={onChange}
                placeholder={placeholder}
                required={required}
                className={`w-full px-3 py-2 bg-[#121212] border border-gray-700 rounded-md text-white placeholder-gray-500 focus:border-[#1db954] focus:outline-none ${className || ''}`}
            />
        );

        const Checkbox = ({ checked, onChange, id }) => (
            <input
                id={id}
                type="checkbox"
                checked={checked}
                onChange={(e) => onChange(e.target.checked)}
                className="w-4 h-4 text-[#1db954] bg-gray-700 border-gray-600 rounded focus:ring-[#1db954] focus:ring-2"
            />
        );

        // Icons as simple SVGs
        const LogInIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1" />
            </svg>
        );

        const LoaderIcon = () => (
            <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        );

        const ChevronDownIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
        );

        const ChevronUpIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
            </svg>
        );

        const ExternalLinkIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
            </svg>
        );

        const SpotifyMusicManager = () => {
            const [isAdvancedOpen, setIsAdvancedOpen] = useState(false);
            const [isLoading, setIsLoading] = useState(false);
            const [isLoggedIn, setIsLoggedIn] = useState(false);
            const [result, setResult] = useState(null);
            const [error, setError] = useState(''); // Added missing error state
            const [formData, setFormData] = useState({
                playlistName: "My Liked Songs",
                isPublic: false,
                songLimit: "",
                explicitFilter: "all", // "all", "explicit", "clean"
                popularityFilter: "", // minimum popularity (0-100)
                releaseDateFilter: "", // year filter (e.g., "2020")
                durationFilter: "", // max duration in minutes
                excludeRemixes: false,
                excludeLive: false,
            });

            // GLOBAL ERROR CATCHER - Catches ANY unhandled errors in the entire app
            useEffect(() => {
                const handleGlobalError = (event) => {
                    console.error('GLOBAL ERROR CAUGHT:', event.error);
                    try {
                        setError(`Unexpected error: ${event.error?.message || 'Something went wrong'}. Please refresh the page.`);
                        setIsLoading(false);
                    } catch (e) {
                        console.error('Failed to handle global error:', e);
                        alert('Critical error - please refresh the page');
                    }
                };

                const handleUnhandledRejection = (event) => {
                    console.error('UNHANDLED PROMISE REJECTION:', event.reason);
                    try {
                        setError(`Network or processing error: ${event.reason?.message || 'Something went wrong'}. Please try again.`);
                        setIsLoading(false);
                    } catch (e) {
                        console.error('Failed to handle promise rejection:', e);
                        alert('Critical error - please refresh the page');
                    }
                };

                // Add global error listeners
                window.addEventListener('error', handleGlobalError);
                window.addEventListener('unhandledrejection', handleUnhandledRejection);

                // Cleanup on unmount
                return () => {
                    window.removeEventListener('error', handleGlobalError);
                    window.removeEventListener('unhandledrejection', handleUnhandledRejection);
                };
            }, []);

            // Spotify OAuth Configuration
            const SPOTIFY_CONFIG = {
                client_id: '6aa4b46ee49d40a292632af532a593b3',
                redirect_uri: `${window.location.origin}/callback.html`,
                scope: 'user-library-read playlist-modify-private playlist-modify-public'
            };

            // ULTIMATE FALLBACK SYSTEM - Catches EVERYTHING that slips through
            const ultimateFallback = (error, context = 'Unknown') => {
                console.error(`ULTIMATE FALLBACK TRIGGERED in ${context}:`, error);
                
                // Force clear all problematic states
                try {
                    setIsLoading(false);
                    setResult(null);
                } catch (e) {
                    console.error('Error clearing states:', e);
                }
                
                // Try to extract any meaningful message
                let message = 'Something unexpected happened';
                
                try {
                    if (typeof error === 'string') {
                        message = error;
                    } else if (error?.message) {
                        message = error.message;
                    } else if (error?.toString) {
                        message = error.toString();
                    } else {
                        message = JSON.stringify(error);
                    }
                } catch (e) {
                    message = 'An unknown error occurred';
                }
                
                // Set error with fallback message
                try {
                    setError(`ERROR: ${message}. Please refresh the page and try again. If this keeps happening, try clearing your browser cache.`);
                } catch (e) {
                    // Even setError failed - this should never happen but just in case
                    console.error('Even setError failed:', e);
                    alert('Critical error - please refresh the page');
                }
            };

            // COMPREHENSIVE ERROR HANDLER - Handles ALL possible errors
            const handleError = (error, context = '') => {
                try {
                    console.error(`Error in ${context}:`, error);
                    
                    // Clear any existing results
                    setResult(null);
                    setIsLoading(false);
                    
                    // Check for specific error types
                    if (typeof error === 'string') {
                        setError(error);
                        return;
                    }
                    
                    const errorMessage = error?.message || 'Unknown error occurred';
                    
                    // Token/Authentication Errors
                    if (errorMessage.includes('token') || 
                        errorMessage.includes('unauthorized') || 
                        errorMessage.includes('forbidden') ||
                        errorMessage.includes('401') ||
                        errorMessage.includes('403') ||
                        errorMessage.includes('invalid_token') ||
                        errorMessage.includes('expired')) {
                        
                        localStorage.removeItem('access_token');
                        localStorage.removeItem('token_expiry');
                        setIsLoggedIn(false);
                        setError('Your session has expired or access is forbidden. Please login again.');
                        return;
                    }
                    
                    // JSON/Parse Errors
                    if (errorMessage.includes('JSON') || 
                        errorMessage.includes('Unexpected token') ||
                        errorMessage.includes('SyntaxError')) {
                        setError('Server returned invalid data. Please check your internet connection and try again.');
                        return;
                    }
                    
                    // Network Errors
                    if (errorMessage.includes('fetch') || 
                        errorMessage.includes('network') ||
                        errorMessage.includes('Failed to fetch')) {
                        setError('Network error. Please check your internet connection and try again.');
                        return;
                    }
                    
                    // Spotify API Errors
                    if (errorMessage.includes('spotify') || 
                        errorMessage.includes('playlist') ||
                        errorMessage.includes('tracks')) {
                        setError('Spotify API error. Please try again in a few moments.');
                        return;
                    }
                    
                    // Rate Limit Errors
                    if (errorMessage.includes('rate') || 
                        errorMessage.includes('limit') ||
                        errorMessage.includes('429')) {
                        setError('Too many requests. Please wait a minute and try again.');
                        return;
                    }
                    
                    // Generic error fallback
                    setError(`Something went wrong: ${errorMessage}. Please try again.`);
                    
                } catch (fallbackError) {
                    // If even handleError fails, use ultimate fallback
                    ultimateFallback(error, `handleError-${context}`);
                }
            };

            // BULLETPROOF API CALLER - Never fails silently
            const makeSpotifyAPICall = async (url, options = {}) => {
                try {
                    const token = localStorage.getItem('access_token');
                    if (!token) {
                        throw new Error('No access token found. Please login again.');
                    }

                    const headers = { 
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                        ...options.headers
                    };

                    const response = await fetch(url, { ...options, headers });
                    
                    // Check if response is ok
                    if (!response.ok) {
                        if (response.status === 401) {
                            throw new Error('TOKEN_EXPIRED');
                        }
                        if (response.status === 403) {
                            throw new Error('Access forbidden. Please logout and login again.');
                        }
                        if (response.status === 429) {
                            throw new Error('Rate limit exceeded. Please wait and try again.');
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    // Check content type
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server returned non-JSON response');
                    }

                    const data = await response.json();
                    
                    // Check for Spotify API errors in response
                    if (data.error) {
                        if (data.error === 'invalid_token' || data.error_description?.includes('token')) {
                            throw new Error('TOKEN_EXPIRED');
                        }
                        throw new Error(data.error_description || data.error);
                    }

                    return { response, data };
                    
                } catch (error) {
                    try {
                        if (error.message === 'TOKEN_EXPIRED') {
                            localStorage.removeItem('access_token');
                            localStorage.removeItem('token_expiry');
                            setIsLoggedIn(false);
                            throw new Error('Your session has expired. Please login again.');
                        }
                        throw error;
                    } catch (fallbackError) {
                        // If even error handling fails, use ultimate fallback
                        ultimateFallback(error, 'makeSpotifyAPICall');
                        throw fallbackError;
                    }
                }
            };

            // Check if user is logged in on component mount
            useEffect(() => {
                const token = localStorage.getItem('access_token');
                const tokenExpiry = localStorage.getItem('token_expiry');
                
                // Check if token exists and hasn't expired
                if (token && tokenExpiry) {
                    const now = new Date().getTime();
                    const expiryTime = parseInt(tokenExpiry);
                    
                    // Give 5 minute buffer before expiry
                    if (now < (expiryTime - 300000)) {
                        setIsLoggedIn(true);
                    } else {
                        // Token expired or about to expire, clear it
                        localStorage.removeItem('access_token');
                        localStorage.removeItem('token_expiry');
                        setIsLoggedIn(false);
                    }
                } else if (token) {
                    // Old token without expiry, keep it and add expiry (assume valid for 3 hours)
                    const newExpiryTime = new Date().getTime() + (10800 * 1000); // 3 hours
                    localStorage.setItem('token_expiry', newExpiryTime.toString());
                    setIsLoggedIn(true);
                }

                // Handle OAuth callback
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                
                if (code && !token) {
                    handleOAuthCallback(code);
                }
            }, []);

            // Handle OAuth login
            const handleLogin = () => {
                const authUrl = `https://accounts.spotify.com/authorize?` +
                    `response_type=code&` +
                    `client_id=${SPOTIFY_CONFIG.client_id}&` +
                    `scope=${encodeURIComponent(SPOTIFY_CONFIG.scope)}&` +
                    `redirect_uri=${encodeURIComponent(SPOTIFY_CONFIG.redirect_uri)}`;
                
                window.location.href = authUrl;
            };

            // Handle OAuth callback
            const handleOAuthCallback = async (code) => {
                try {
                    const response = await fetch('https://accounts.spotify.com/api/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Authorization': 'Basic ' + btoa(`${SPOTIFY_CONFIG.client_id}:d59645a4c1ae4313a892f62a3abbabf7`)
                        },
                        body: new URLSearchParams({
                            grant_type: 'authorization_code',
                            code: code,
                            redirect_uri: SPOTIFY_CONFIG.redirect_uri
                        })
                    });

                    // Check if response is OK before parsing JSON
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Spotify API error:', response.status, errorText);
                        setError(`Authentication failed. Please try logging in again.`);
                        return;
                    }

                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        const errorText = await response.text();
                        console.error('Non-JSON response from Spotify:', errorText);
                        setError('Authentication service returned an unexpected response. Please try again.');
                        return;
                    }

                    const data = await response.json();
                    
                    if (data.access_token) {
                        localStorage.setItem('access_token', data.access_token);
                        
                        // Calculate and store expiry time (extend to 3 hours for better UX)
                        const expiresIn = data.expires_in || 3600; // Default to 1 hour from Spotify
                        const extendedExpiry = Math.max(expiresIn, 10800); // Minimum 3 hours
                        const expiryTime = new Date().getTime() + (extendedExpiry * 1000);
                        localStorage.setItem('token_expiry', expiryTime.toString());
                        
                        setIsLoggedIn(true);
                        window.history.replaceState({}, document.title, window.location.pathname);
                    } else if (data.error) {
                        console.error('Spotify API error:', data.error, data.error_description);
                        setError(`Spotify authentication error: ${data.error_description || data.error}`);
                    } else {
                        console.error('No access token received:', data);
                        setError('Authentication failed. Please try again.');
                    }
                } catch (error) {
                    handleError(error, 'OAuth callback');
                }
            };

            // Handle logout
            const handleLogout = () => {
                localStorage.removeItem('access_token');
                localStorage.removeItem('token_expiry');
                setIsLoggedIn(false);
                setResult(null);
            };

            // Helper function to check if API response indicates expired token
            const isTokenExpired = (response, data) => {
                return response.status === 401 || 
                       (data && (data.error === 'invalid_token' || 
                                data.error_description?.includes('token') ||
                                data.error_description?.includes('expired')));
            };

            // Main transfer function
            const handleSubmit = async (e) => {
                e.preventDefault();
                
                // Clear any previous errors
                setError('');
                setResult(null);
                
                if (!isLoggedIn) {
                    handleError('Please login with Spotify first.', 'handleSubmit');
                    return;
                }

                setIsLoading(true);

                try {
                    // 1. Get User ID
                    const { data: user } = await makeSpotifyAPICall('https://api.spotify.com/v1/me');

                    // 2. Create Playlist
                    const playlistData = {
                        name: formData.playlistName,
                        description: `Auto-created from Liked Songs on ${new Date().toLocaleDateString()}`,
                        public: formData.isPublic
                    };

                    const { data: playlist } = await makeSpotifyAPICall(`https://api.spotify.com/v1/users/${user.id}/playlists`, {
                        method: 'POST',
                        body: JSON.stringify(playlistData)
                    });

                    // 3. Fetch Liked Songs with Filtering
                    let offset = 0;
                    let allTracks = [];
                    const songLimit = formData.songLimit ? parseInt(formData.songLimit) : null;

                    while (true) {
                        const { data: tracksData } = await makeSpotifyAPICall(
                            `https://api.spotify.com/v1/me/tracks?limit=50&offset=${offset}`
                        );

                        allTracks.push(...tracksData.items);

                        if (tracksData.items.length < 50) break;
                        offset += 50;

                        // Don't fetch more than needed if we have a song limit
                        if (songLimit && allTracks.length >= songLimit * 2) break; // Fetch extra for filtering
                    }

                    // Apply filters
                    let filteredTracks = allTracks.filter(item => {
                        const track = item.track;
                        
                        // Explicit content filter
                        if (formData.explicitFilter === 'clean' && track.explicit) return false;
                        if (formData.explicitFilter === 'explicit' && !track.explicit) return false;
                        
                        // Popularity filter
                        if (formData.popularityFilter && track.popularity < parseInt(formData.popularityFilter)) return false;
                        
                        // Duration filter (convert ms to minutes)
                        if (formData.durationFilter && (track.duration_ms / 60000) > parseInt(formData.durationFilter)) return false;
                        
                        // Release date filter
                        if (formData.releaseDateFilter) {
                            const releaseYear = new Date(track.album.release_date).getFullYear();
                            if (releaseYear < parseInt(formData.releaseDateFilter)) return false;
                        }
                        
                        // Exclude remixes
                        if (formData.excludeRemixes) {
                            const trackName = track.name.toLowerCase();
                            if (trackName.includes('remix') || trackName.includes('mix') || trackName.includes('rmx')) return false;
                        }
                        
                        // Exclude live versions
                        if (formData.excludeLive) {
                            const trackName = track.name.toLowerCase();
                            if (trackName.includes('live') || trackName.includes('concert') || trackName.includes('tour')) return false;
                        }
                        
                        return true;
                    });

                    // Apply song limit after filtering
                    if (songLimit && filteredTracks.length > songLimit) {
                        filteredTracks = filteredTracks.slice(0, songLimit);
                    }

                    const uris = filteredTracks.map(item => item.track.uri);

                    // 4. Add Songs to Playlist (100 at a time)
                    const batchSize = 100;
                    for (let i = 0; i < uris.length; i += batchSize) {
                        const batch = uris.slice(i, i + batchSize);
                        
                        await makeSpotifyAPICall(`https://api.spotify.com/v1/playlists/${playlist.id}/tracks`, {
                            method: 'POST',
                            body: JSON.stringify({ uris: batch })
                        });
                    }

                    // Success!
                    setError(''); // Clear any errors
                    
                    // Build filter summary for success message
                    let filterSummary = [];
                    if (formData.explicitFilter === 'clean') filterSummary.push('clean songs only');
                    if (formData.explicitFilter === 'explicit') filterSummary.push('explicit songs only');
                    if (formData.popularityFilter) filterSummary.push(`popularity ‚â•${formData.popularityFilter}`);
                    if (formData.durationFilter) filterSummary.push(`‚â§${formData.durationFilter} min`);
                    if (formData.releaseDateFilter) filterSummary.push(`from ${formData.releaseDateFilter}+`);
                    if (formData.excludeRemixes) filterSummary.push('no remixes');
                    if (formData.excludeLive) filterSummary.push('no live versions');
                    
                    const filterText = filterSummary.length > 0 ? ` (${filterSummary.join(', ')})` : '';
                    
                    setResult({
                        type: "success",
                        message: `Successfully created "${formData.playlistName}"!`,
                        link: playlist.external_urls.spotify,
                        tracks: uris.length,
                        filterInfo: filterText
                    });

                } catch (error) {
                    try {
                        handleError(error, 'handleSubmit');
                    } catch (fallbackError) {
                        ultimateFallback(error, 'handleSubmit');
                    }
                } finally {
                    try {
                        setIsLoading(false);
                    } catch (error) {
                        console.error('Failed to set loading state:', error);
                    }
                }
            };

            return (
                <div className="min-h-screen bg-[#121212] text-white">
                    {/* Header */}
                    <header className="bg-gradient-to-br from-[#1e1e1e] via-[#121212] to-[#0a0a0a] border-b border-gray-800 relative overflow-hidden">
                        <div className="absolute inset-0 bg-gradient-to-r from-transparent via-[#1db954]/5 to-transparent"></div>
                        <div className="relative max-w-6xl mx-auto px-4 py-8">
                            <div className="text-center">
                                <h1 className="text-4xl font-bold mb-2 flex items-center justify-center gap-3 bg-gradient-to-r from-white via-gray-100 to-[#1db954] bg-clip-text text-transparent">
                                    SyncLiked
                                </h1>
                                <p className="text-gray-400 text-lg">Instantly convert your liked songs into a custom playlist!</p>
                            </div>
                            
                            {/* Login/Logout Button */}
                            <div className="flex justify-center mt-6">
                                {isLoggedIn ? (
                                    <Button onClick={handleLogout} variant="outline">
                                        Logout from Spotify
                                    </Button>
                                ) : (
                                    <Button onClick={handleLogin} className="rounded-[25px] py-3 px-8">
                                        <LogInIcon /> Login with Spotify
                                    </Button>
                                )}
                            </div>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto px-4 py-8">
                        {/* Feature Cards */}
                        <section className="mb-12">
                            <h2 className="text-2xl font-bold text-center mb-8">Why Choose SyncLiked?</h2>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                                <Card className="hover:border-[#1db954] transition-colors duration-300">
                                    <div className="p-6 text-center">
                                        <div className="flex justify-center mb-4 text-[#1db954] text-4xl">üìÅ</div>
                                        <h3 className="text-white text-xl font-semibold mb-2">Organize</h3>
                                        <p className="text-gray-400">Turn your massive liked songs collection into organized playlists</p>
                                    </div>
                                </Card>
                                <Card className="hover:border-[#1db954] transition-colors duration-300">
                                    <div className="p-6 text-center">
                                        <div className="flex justify-center mb-4 text-[#1db954] text-4xl">üì§</div>
                                        <h3 className="text-white text-xl font-semibold mb-2">Share</h3>
                                        <p className="text-gray-400">Make your favorite music shareable with friends</p>
                                    </div>
                                </Card>
                                <Card className="hover:border-[#1db954] transition-colors duration-300">
                                    <div className="p-6 text-center">
                                        <div className="flex justify-center mb-4 text-[#1db954] text-4xl">‚ö°</div>
                                        <h3 className="text-white text-xl font-semibold mb-2">Fast</h3>
                                        <p className="text-gray-400">Transfer hundreds of songs in seconds</p>
                                    </div>
                                </Card>
                            </div>
                        </section>

                        {/* Main Form */}
                        {isLoggedIn && (
                            <section className="mb-8">
                                <Card>
                                    <div className="p-6">
                                        <h3 className="text-white text-xl font-semibold mb-2">Transfer Liked Songs to Playlist</h3>
                                        <p className="text-gray-400 mb-6">Create a new playlist from your liked songs with custom preferences</p>
                                        
                                        <form onSubmit={handleSubmit} className="space-y-6">
                                            <div className="space-y-2">
                                                <label htmlFor="playlistName" className="text-white block">Playlist Name *</label>
                                                <Input
                                                    id="playlistName"
                                                    type="text"
                                                    placeholder="Enter playlist name..."
                                                    value={formData.playlistName}
                                                    onChange={(e) => setFormData(prev => ({ ...prev, playlistName: e.target.value }))}
                                                    required
                                                />
                                            </div>

                                            {/* Advanced Options */}
                                            <div className="border-t border-gray-700 pt-6">
                                                <Button
                                                    type="button"
                                                    variant="ghost"
                                                    onClick={() => setIsAdvancedOpen(!isAdvancedOpen)}
                                                    className="p-0 h-auto font-medium"
                                                >
                                                    Advanced Options
                                                    {isAdvancedOpen ? <ChevronUpIcon /> : <ChevronDownIcon />}
                                                </Button>

                                                {isAdvancedOpen && (
                                                    <div className="mt-4 space-y-4 p-4 bg-[#121212] rounded-lg border border-gray-700">
                                                        <div className="flex items-center space-x-2">
                                                            <Checkbox
                                                                id="isPublic"
                                                                checked={formData.isPublic}
                                                                onChange={(checked) => setFormData(prev => ({ ...prev, isPublic: checked }))}
                                                            />
                                                            <label htmlFor="isPublic" className="text-white text-sm">Make playlist public</label>
                                                        </div>

                                                        <div className="space-y-2">
                                                            <label htmlFor="songLimit" className="text-white text-sm block">Limit number of songs (optional)</label>
                                                            <Input
                                                                id="songLimit"
                                                                type="number"
                                                                placeholder="Leave empty for all songs"
                                                                value={formData.songLimit}
                                                                onChange={(e) => setFormData(prev => ({ ...prev, songLimit: e.target.value }))}
                                                                className="bg-[#0a0a0a] border-gray-600"
                                                            />
                                                        </div>

                                                        {/* Content Filtering */}
                                                        <div className="space-y-3 border-t border-gray-600 pt-4">
                                                            <h4 className="text-white text-sm font-medium">Content Filters</h4>
                                                            
                                                            <div className="space-y-2">
                                                                <label className="text-white text-sm block">Explicit Content</label>
                                                                <select
                                                                    value={formData.explicitFilter}
                                                                    onChange={(e) => setFormData(prev => ({ ...prev, explicitFilter: e.target.value }))}
                                                                    className="w-full px-3 py-2 bg-[#0a0a0a] border border-gray-600 rounded-md text-white focus:border-[#1db954] focus:outline-none"
                                                                >
                                                                    <option value="all">All songs (explicit + clean)</option>
                                                                    <option value="clean">Only clean songs (no explicit)</option>
                                                                    <option value="explicit">Only explicit songs</option>
                                                                </select>
                                                            </div>

                                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                                                                <div className="flex items-center space-x-2">
                                                                    <Checkbox
                                                                        id="excludeRemixes"
                                                                        checked={formData.excludeRemixes}
                                                                        onChange={(checked) => setFormData(prev => ({ ...prev, excludeRemixes: checked }))}
                                                                    />
                                                                    <label htmlFor="excludeRemixes" className="text-white text-sm">Exclude remixes</label>
                                                                </div>

                                                                <div className="flex items-center space-x-2">
                                                                    <Checkbox
                                                                        id="excludeLive"
                                                                        checked={formData.excludeLive}
                                                                        onChange={(checked) => setFormData(prev => ({ ...prev, excludeLive: checked }))}
                                                                    />
                                                                    <label htmlFor="excludeLive" className="text-white text-sm">Exclude live versions</label>
                                                                </div>
                                                            </div>
                                                        </div>

                                                        {/* Quality & Popularity Filters */}
                                                        <div className="space-y-3 border-t border-gray-600 pt-4">
                                                            <h4 className="text-white text-sm font-medium">Quality Filters</h4>
                                                            
                                                            <div className="space-y-2">
                                                                <label htmlFor="popularityFilter" className="text-white text-sm block">Minimum popularity (0-100)</label>
                                                                <Input
                                                                    id="popularityFilter"
                                                                    type="number"
                                                                    min="0"
                                                                    max="100"
                                                                    placeholder="e.g., 50 for moderately popular"
                                                                    value={formData.popularityFilter}
                                                                    onChange={(e) => setFormData(prev => ({ ...prev, popularityFilter: e.target.value }))}
                                                                    className="bg-[#0a0a0a] border-gray-600"
                                                                />
                                                            </div>

                                                            <div className="space-y-2">
                                                                <label htmlFor="durationFilter" className="text-white text-sm block">Maximum song duration (minutes)</label>
                                                                <Input
                                                                    id="durationFilter"
                                                                    type="number"
                                                                    min="1"
                                                                    max="30"
                                                                    placeholder="e.g., 5 for max 5 minutes"
                                                                    value={formData.durationFilter}
                                                                    onChange={(e) => setFormData(prev => ({ ...prev, durationFilter: e.target.value }))}
                                                                    className="bg-[#0a0a0a] border-gray-600"
                                                                />
                                                            </div>
                                                        </div>

                                                        {/* Date Filters */}
                                                        <div className="space-y-3 border-t border-gray-600 pt-4">
                                                            <h4 className="text-white text-sm font-medium">Date Filters</h4>
                                                            
                                                            <div className="space-y-2">
                                                                <label htmlFor="releaseDateFilter" className="text-white text-sm block">Released after year (optional)</label>
                                                                <Input
                                                                    id="releaseDateFilter"
                                                                    type="number"
                                                                    min="1900"
                                                                    max="2025"
                                                                    placeholder="e.g., 2020 for songs from 2020 onwards"
                                                                    value={formData.releaseDateFilter}
                                                                    onChange={(e) => setFormData(prev => ({ ...prev, releaseDateFilter: e.target.value }))}
                                                                    className="bg-[#0a0a0a] border-gray-600"
                                                                />
                                                            </div>
                                                        </div>

                                                        <div className="text-xs text-gray-500 bg-[#0a0a0a] p-3 rounded border border-gray-700">
                                                            <strong>Pro tip:</strong> These filters help you create themed playlists like "Clean Hits Only", "Recent Bangers", or "Short & Sweet Songs"!
                                                        </div>
                                                    </div>
                                                )}
                                            </div>

                                            {/* Action Buttons */}
                                            <div className="flex flex-col sm:flex-row gap-3 pt-4">
                                                <Button
                                                    type="submit"
                                                    disabled={isLoading}
                                                    className="rounded-[25px] py-3 px-8"
                                                >
                                                    {isLoading ? (
                                                        <>
                                                            <LoaderIcon />
                                                            Creating Playlist...
                                                        </>
                                                    ) : (
                                                        "Transfer Liked Songs to Playlist"
                                                    )}
                                                </Button>

                                                <Button
                                                    type="button"
                                                    variant="outline"
                                                    className="rounded-[25px] py-3 px-8"
                                                    onClick={() => {
                                                        setFormData({
                                                            playlistName: "My Liked Songs",
                                                            isPublic: false,
                                                            songLimit: "",
                                                            explicitFilter: "all",
                                                            popularityFilter: "",
                                                            releaseDateFilter: "",
                                                            durationFilter: "",
                                                            excludeRemixes: false,
                                                            excludeLive: false,
                                                        });
                                                        setResult(null);
                                                    }}
                                                >
                                                    Reset Form
                                                </Button>
                                            </div>
                                        </form>
                                    </div>
                                </Card>
                            </section>
                        )}

                        {/* Error Display Section */}
                        {error && (
                            <section className="mb-8">
                                <Card className="border-2 bg-red-900/20 border-red-600">
                                    <div className="p-6">
                                        <div className="flex items-center justify-between flex-wrap gap-4">
                                            <div>
                                                <p className="font-medium text-red-400">
                                                    WARNING: {error}
                                                </p>
                                                <p className="text-gray-400 text-sm mt-1">
                                                    If this problem persists, try refreshing the page or clearing your browser cache.
                                                </p>
                                            </div>
                                            <div className="flex gap-2">
                                                <Button
                                                    variant="ghost"
                                                    onClick={() => {
                                                        // RECOVERY MODE - Clears everything and resets app
                                                        try {
                                                            localStorage.clear();
                                                            setError('');
                                                            setResult(null);
                                                            setIsLoggedIn(false);
                                                            setIsLoading(false);
                                                            setFormData({
                                                                playlistName: "My Liked Songs",
                                                                isPublic: false,
                                                                songLimit: "",
                                                                explicitFilter: "all",
                                                                popularityFilter: "",
                                                                releaseDateFilter: "",
                                                                durationFilter: "",
                                                                excludeRemixes: false,
                                                                excludeLive: false,
                                                            });
                                                            window.location.reload();
                                                        } catch (e) {
                                                            alert('Please manually refresh the page');
                                                        }
                                                    }}
                                                    className="text-yellow-400 hover:text-yellow-300 text-xs"
                                                >
                                                    RECOVERY MODE
                                                </Button>
                                                <Button
                                                    variant="ghost"
                                                    onClick={() => setError('')}
                                                    className="text-red-400 hover:text-red-300"
                                                >
                                                    Dismiss
                                                </Button>
                                            </div>
                                        </div>
                                    </div>
                                </Card>
                            </section>
                        )}

                        {/* Results Section */}
                        {result && (
                            <section className="mb-8">
                                <Card className={`border-2 ${
                                    result.type === "success" ? "bg-green-900/20 border-green-600" : "bg-red-900/20 border-red-600"
                                }`}>
                                    <div className="p-6">
                                        <div className="flex items-center justify-between flex-wrap gap-4">
                                            <div>
                                                <p className={`font-medium ${result.type === "success" ? "text-green-400" : "text-red-400"}`}>
                                                    {result.message}
                                                </p>
                                                {result.tracks && (
                                                    <p className="text-gray-400 text-sm mt-1">
                                                        Transferred {result.tracks} tracks successfully{result.filterInfo}
                                                    </p>
                                                )}
                                            </div>
                                            {result.link && (
                                                <Button
                                                    variant="ghost" 
                                                    onClick={() => window.open(result.link, '_blank')}
                                                    className="text-sm"
                                                >
                                                    Open in Spotify <ExternalLinkIcon />
                                                </Button>
                                            )}
                                        </div>
                                    </div>
                                </Card>
                            </section>
                        )}

                    </main>
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<SpotifyMusicManager />, document.getElementById('root'));
    </script>
</body>
</html>
